containerized: "docker://aurelia01/genome_assembly_pipeline:v0.3.5"
configfile: "config/config.yml"

assembly_name = config["assembly_name"]

def oatkdb_path():
    mito_fam = f"results/downloads/oatkdb/{config['oatk_lineage']}_mito.fam"
    pltd_fam = f"results/downloads/oatkdb/{config['oatk_lineage']}_pltd.fam"
    if config["oatk_organelle"] == "mito":
        return {"mito_fam": mito_fam}
    elif config["oatk_organelle"] == "pltd":
        return {"pltd_fam": pltd_fam}
    elif config["oatk_organelle"] == "mito_and_pltd":
        return {"mito_fam": mito_fam, "pltd_fam": pltd_fam}
    else:
        raise ValueError("Invalid value for 'oatk_organelle' in config.yml. Must be one of 'mito', 'pltd', or 'mito_and_pltd'.")

def oatk_output_path():
    utg_final_gfa = "results/oatk/oatk/{assembly_name}.utg.final.gfa"
    annot_mito_txt = "results/oatk/oatk/{assembly_name}.annot_mito.txt"
    annot_pltd_txt = "results/oatk/oatk/{assembly_name}.annot_pltd.txt"
    mito_gfa = "results/oatk/oatk/{assembly_name}.mito.gfa"
    mito_bed = "results/oatk/oatk/{assembly_name}.mito.bed"
    mito_ctg_fasta = "results/oatk/oatk/{assembly_name}.mito.ctg.fasta"
    mito_ctg_bed = "results/oatk/oatk/{assembly_name}.mito.ctg.bed"
    pltd_gfa = "results/oatk/oatk/{assembly_name}.pltd.gfa"
    pltd_bed = "results/oatk/oatk/{assembly_name}.pltd.bed"
    pltd_ctg_fasta = "results/oatk/oatk/{assembly_name}.pltd.ctg.fasta"
    pltd_ctg_bed = "results/oatk/oatk/{assembly_name}.pltd.ctg.bed"
    if config["oatk_organelle"] == "mito":
        return {
            "utg_final_gfa": utg_final_gfa,
            "annot_mito_txt": annot_mito_txt,
            "mito_gfa": mito_gfa,
            "mito_bed": mito_bed,
            "mito_ctg_fasta": mito_ctg_fasta,
            "mito_ctg_bed": mito_ctg_bed
        }
    elif config["oatk_organelle"] == "pltd":
        return {
            "utg_final_gfa": utg_final_gfa,
            "annot_pltd_txt": annot_pltd_txt,
            "pltd_gfa": pltd_gfa,
            "pltd_bed": pltd_bed,
            "pltd_ctg_fasta": pltd_ctg_fasta,
            "pltd_ctg_bed": pltd_ctg_bed
        }
    elif config["oatk_organelle"] == "mito_and_pltd":
        return {
            "utg_final_gfa": utg_final_gfa,
            "annot_mito_txt": annot_mito_txt,
            "annot_pltd_txt": annot_pltd_txt,
            "mito_gfa": mito_gfa,
            "mito_bed": mito_bed,
            "mito_ctg_fasta": mito_ctg_fasta,
            "mito_ctg_bed": mito_ctg_bed,
            "pltd_gfa": pltd_gfa,
            "pltd_bed": pltd_bed,
            "pltd_ctg_fasta": pltd_ctg_fasta,
            "pltd_ctg_bed": pltd_ctg_bed
        }
    else:
        raise ValueError("Invalid value for 'oatk_organelle' in config.yml. Must be one of 'mito', 'pltd', or 'mito_and_pltd'.")

def oatk_output_real_path(assembly_name):
    return [v.format(assembly_name=assembly_name) for v in oatk_output_path().values()]

include: "rules/genome_assembly.smk"
include: "rules/softmask.smk"
include: "rules/gene_prediction.smk"

# Step 1: Genome assembly
def assembly_all_inputs(assembly_name):
    return [
        f"results/hifi_reads/smudgeplot/{assembly_name}_masked_errors_smu.txt",
        f"results/hifi_reads/genomescope2/{assembly_name}_summary.txt",
        *oatk_output_real_path(assembly_name),
        f"results/hifiasm/seqkit/{assembly_name}_seqkit_stats.tsv",
        f"results/hifiasm/gc_content/{assembly_name}_gc_content.pdf",
        f"results/hifiasm/busco_genome/BUSCO_{assembly_name}.asm.bp.p_ctg.fa",
        f"results/hifiasm/merqury/{assembly_name}.merqury.qv",
        f"results/hifiasm/depth/{assembly_name}_contig_depth.pdf",
        f"results/hifiasm/tidk/{assembly_name}_tidk_find.svg",
        f"results/hifiasm/tidk/{assembly_name}_tidk_explore.tsv",
        f"results/hifiasm/tidk/{assembly_name}_tidk_search.svg"
    ]

# Step 2: Organelle removal
def remove_organelle_all_inputs(assembly_name):
    return assembly_all_inputs(assembly_name) + [
        f"results/organelle_removal/seqkit/{assembly_name}_seqkit_stats.tsv",
        f"results/organelle_removal/gc_content/{assembly_name}_gc_content.pdf",
        f"results/organelle_removal/busco_genome/BUSCO_{assembly_name}.asm.bp.p_ctg.fa",
        f"results/organelle_removal/merqury/{assembly_name}.merqury.qv",
        f"results/organelle_removal/depth/{assembly_name}_contig_depth.pdf",
        f"results/organelle_removal/tidk/{assembly_name}_tidk_find.svg",
        f"results/organelle_removal/tidk/{assembly_name}_tidk_explore.tsv",
        f"results/organelle_removal/tidk/{assembly_name}_tidk_search.svg",
        f"results/hifiasm/map_to_organelle/organelle_contig_depth/{assembly_name}_contig_depth.pdf"
    ]

# Step 3: Contamination removal by FCS
def remove_contamination_all_inputs(assembly_name):
    return remove_organelle_all_inputs(assembly_name) + [
        f"results/fcs/seqkit/{assembly_name}_seqkit_stats.tsv",
        f"results/fcs/gc_content/{assembly_name}_gc_content.pdf",
        f"results/fcs/busco_genome/BUSCO_{assembly_name}.asm.bp.p_ctg.fa",
        f"results/fcs/merqury/{assembly_name}.merqury.qv",
        f"results/fcs/depth/{assembly_name}_contig_depth.pdf",
        f"results/downloads/tidk/.{assembly_name}_.local_share_tidk_successfully_removed_or_restored.txt"
    ]

# Step 4: Soft-masking
def softmask_all_inputs(assembly_name):
    return remove_contamination_all_inputs(assembly_name) + [
        f"results/repeatmasker/{assembly_name}.asm.bp.p_ctg.fa.masked"
    ]

# Step 5: Gene prediction
def gene_prediction_all_inputs(assembly_name):
    return softmask_all_inputs(assembly_name) + [
        f"results/isoforms/busco_proteins/BUSCO_{assembly_name}_aa.fa",
        f"results/longest_cds/busco_proteins/BUSCO_{assembly_name}_aa.fa",
        f"results/isoforms/seqkit/{assembly_name}_seqkit_stats.tsv",
        f"results/longest_cds/seqkit/{assembly_name}_seqkit_stats.tsv",
        f"results/longest_cds/omark/{assembly_name}_omark"
    ]

rule all:
    input:
        *gene_prediction_all_inputs(assembly_name)

rule assembly_all:
    input:
        *assembly_all_inputs(assembly_name)

rule remove_organelle_all:
    input:
        *remove_organelle_all_inputs(assembly_name)

rule remove_contamination_all:
    input:
        *remove_contamination_all_inputs(assembly_name)

rule softmask_all:
    input:
        *softmask_all_inputs(assembly_name)

rule gene_prediction_all:
    input:
        *gene_prediction_all_inputs(assembly_name)
